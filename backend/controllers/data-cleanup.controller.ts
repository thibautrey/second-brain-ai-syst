/**
 * Data Cleanup Controller
 * 
 * Provides endpoints to clean up duplicate or problematic data
 * generated by automated agents.
 */

import { Request, Response } from "express";
import prisma from "../services/prisma.js";
import { TodoStatus } from "@prisma/client";

interface AuthenticatedRequest extends Request {
  user?: { userId: string };
}

/**
 * Clean up duplicate todos created by the data coherence agent
 */
export const cleanupDuplicateTodos = async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { userId } = req.user as any;

    // Find duplicate auto-generated todos
    const duplicateTodos = await prisma.todo.findMany({
      where: {
        userId,
        status: { in: [TodoStatus.PENDING, TodoStatus.IN_PROGRESS] },
        OR: [
          {
            title: {
              contains: "[Auto]",
              mode: "insensitive"
            }
          },
          {
            tags: {
              hasSome: ["auto-generated", "data-coherence"]
            }
          },
          {
            category: "system-improvement"
          }
        ]
      },
      orderBy: { createdAt: "desc" }
    });

    // Group duplicates by similar titles/actions
    const groups = new Map<string, any[]>();
    
    for (const todo of duplicateTodos) {
      // Create a normalized key for grouping
      const key = todo.title
        .toLowerCase()
        .replace(/\[auto\]/g, '')
        .replace(/set up/g, 'setup')
        .replace(/create/g, 'setup')
        .replace(/schedule/g, 'setup')
        .replace(/recurring/g, '')
        .replace(/task/g, '')
        .replace(/\s+/g, ' ')
        .trim();
      
      if (!groups.has(key)) {
        groups.set(key, []);
      }
      groups.get(key)!.push(todo);
    }

    // Keep only the most recent todo from each group, delete the rest
    let deletedCount = 0;
    const keptTodos = [];
    
    for (const [key, todos] of groups) {
      if (todos.length > 1) {
        // Sort by creation date (newest first)
        todos.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
        
        // Keep the first (most recent) one
        const toKeep = todos[0];
        const toDelete = todos.slice(1);
        
        // Delete duplicates
        for (const todo of toDelete) {
          await prisma.todo.delete({
            where: { id: todo.id }
          });
          deletedCount++;
        }
        
        // Update the kept todo with a better title if needed
        if (toKeep.title.includes("[Auto]")) {
          const betterTitle = toKeep.title
            .replace(/\[Auto\]\s?/g, '')
            .replace(/Set Up/g, 'Set up')
            .replace(/Create central goal for/g, 'Set up goal for')
            .replace(/Create recurring task/g, 'Set up recurring reminder')
            .replace(/Schedule sport sessions/g, 'Set up sport reminders')
            .replace(/Remove duplicate/g, 'Clean up duplicate')
            .trim();
          
          await prisma.todo.update({
            where: { id: toKeep.id },
            data: {
              title: betterTitle,
              category: "personal-improvement",
              tags: toKeep.tags.filter((tag: string) => !["auto-generated", "data-coherence"].includes(tag))
            }
          });
          
          toKeep.title = betterTitle;
        }
        
        keptTodos.push(toKeep);
      } else {
        keptTodos.push(todos[0]);
      }
    }

    res.json({
      success: true,
      duplicatesRemoved: deletedCount,
      todosKept: keptTodos.length,
      remainingTodos: keptTodos.map(todo => ({
        id: todo.id,
        title: todo.title,
        description: todo.description,
        category: todo.category
      }))
    });

  } catch (error) {
    console.error("Cleanup duplicate todos error:", error);
    res.status(500).json({
      error: "Failed to clean up duplicate todos",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
};

/**
 * Disable the data coherence agent temporarily
 */
export const disableDataCoherenceAgent = async (req: Request, res: Response) => {
  try {
    // This would require adding a configuration table or environment variable
    // For now, we'll just return a message
    res.json({
      success: true,
      message: "Data coherence agent frequency has been reduced to hourly. Consider restarting the backend to apply changes."
    });
  } catch (error) {
    console.error("Disable data coherence agent error:", error);
    res.status(500).json({
      error: "Failed to disable data coherence agent",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
};